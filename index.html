<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Will You Be My Valentine?</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary-color: #ff4d6d;
            --secondary-color: #ff8fa3;
            --accent-color: #c9184a;
            --bg-gradient: linear-gradient(135deg, #fff0f3 0%, #ffccd5 100%);
            --white: #ffffff;
            --font-heading: 'Great Vibes', cursive;
            --font-body: 'Poppins', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: var(--font-body);
            background: var(--bg-gradient);
            user-select: none; /* Prevent selection during game */
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }

        #score-board {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 20px;
            border-radius: 30px;
            box-shadow: 0 4px 15px rgba(255, 77, 109, 0.2);
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: var(--accent-color);
        }

        .progress-bar {
            width: 150px;
            height: 15px;
            background: #ffe5ec;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid var(--secondary-color);
        }

        #love-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            transition: width 0.3s ease-out;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(255, 240, 243, 0.95); /* Slightly more opaque for readability */
            z-index: 20;
            transition: opacity 0.5s ease;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            display: none; 
        }

        .screen.active {
            opacity: 1;
            pointer-events: auto;
            display: flex;
        }

        h1 {
            font-family: var(--font-heading);
            font-size: 5rem;
            color: var(--accent-color);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.2;
            padding: 0 20px;
        }

        p {
            font-size: 1.2rem;
            color: #590d22;
            margin-bottom: 30px;
            text-align: center;
            padding: 0 20px;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.2rem;
            font-family: var(--font-body);
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(201, 24, 74, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(201, 24, 74, 0.4);
        }

        .btn:active {
            transform: translateY(1px);
        }

        #start-btn {
            background: var(--primary-color);
            color: white;
        }

        .buttons {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .yes-btn {
            background: #2dc653;
            color: white;
            font-size: 1.5rem;
            padding: 20px 60px;
        }

        .no-btn {
            background: #ffb703;
            color: white;
            position: relative; /* Essential for the moving effect */
            transition: all 0.2s;
        }

        /* Animations */
        @keyframes heartbeat {
            0% { transform: scale(1); }
            15% { transform: scale(1.1); }
            30% { transform: scale(1); }
            45% { transform: scale(1.1); }
            60% { transform: scale(1); }
        }

        .proposal-content h1 {
            animation: heartbeat 2s infinite;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-layer">
            <div id="score-board">
                <span>‚ù§Ô∏è Love Meter: </span>
                <div class="progress-bar">
                    <div id="love-fill"></div>
                </div>
            </div>
        </div>

        <div id="start-screen" class="screen active">
            <h1>Catch the Love Emojis!</h1>
            <p>Catch enough hearts to reveal a special question...</p>
            <button id="start-btn" class="btn">Start Game Chudail</button>
        </div>

        <div id="proposal-screen" class="screen hidden">
            <div class="proposal-content" style="text-align: center;">
                <h1>Will You Be My Valentine Ankita?</h1>
                <p class="sub-text">You caught my heart! Now I have to ask...</p>
                <div class="buttons">
                    <button id="yes-btn" class="btn yes-btn">YES!</button>
                    <button id="no-btn" class="btn no-btn">No</button>
                </div>
            </div>
        </div>

        <div id="celebration-screen" class="screen hidden">
            <h1>Happy Propose Day Ankita Madam! üíç</h1>
            <p>I love you !</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game State
        let gameState = 'START'; // START, PLAYING, WON, PROPOSAL, END
        let score = 0;
        const WIN_SCORE = 5; // Hearts needed to fill the meter
        let player;
        let hearts = [];
        let particles = []; // For effects
        let animationId;
        let loveMeter = document.getElementById('love-fill');

        // DOM Elements
        const startScreen = document.getElementById('start-screen');
        const proposalScreen = document.getElementById('proposal-screen');
        const celebrationScreen = document.getElementById('celebration-screen');
        const startBtn = document.getElementById('start-btn');
        const yesBtn = document.getElementById('yes-btn');
        const noBtn = document.getElementById('no-btn');

        // Resize Handling
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (player) {
                 player.y = canvas.height - 100;
                 // Keep player within bounds on resize
                 if(player.x + player.w > canvas.width) player.x = canvas.width - player.w;
            }
        }
        window.addEventListener('resize', resize);

        // Player Object
        class Player {
            constructor() {
                this.w = 100; // width
                this.h = 80;  // height
                this.x = canvas.width / 2 - this.w / 2;
                this.y = canvas.height - 100;
            }

            draw() {
                // Draw a cute basket
                ctx.fillStyle = '#ff4d6d';
                
                // Simple semi-circle basket
                ctx.beginPath();
                ctx.arc(this.x + this.w/2, this.y, this.w/2, 0, Math.PI, false);
                ctx.fill();
                
                // Handle
                ctx.beginPath();
                ctx.strokeStyle = '#c9184a';
                ctx.lineWidth = 5;
                ctx.arc(this.x + this.w/2, this.y - 10, this.w/2, Math.PI, 0, false);
                ctx.stroke();
            }

            update() {
                // Mouse logic handles X directly, just boundary checks here
                if (this.x < 0) this.x = 0;
                if (this.x + this.w > canvas.width) this.x = canvas.width - this.w;
            }
        }

        // Heart Object
        class Heart {
            constructor() {
                this.size = Math.random() * 20 + 20; // 20-40px
                this.x = Math.random() * (canvas.width - this.size);
                this.y = -this.size;
                this.speed = Math.random() * 3 + 2; // 2-5 speed
                this.color = `hsl(${Math.random() * 20 + 340}, 100%, 60%)`; // Pinkish/Red variations
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                let topCurveHeight = this.size * 0.3;
                ctx.moveTo(this.x, this.y + topCurveHeight);
                // top left curve
                ctx.bezierCurveTo(
                    this.x, this.y, 
                    this.x - this.size / 2, this.y, 
                    this.x - this.size / 2, this.y + topCurveHeight
                );
                // bottom left curve
                ctx.bezierCurveTo(
                    this.x - this.size / 2, this.y + (this.size + topCurveHeight) / 2, 
                    this.x, this.y + (this.size + topCurveHeight) / 2, 
                    this.x, this.y + this.size
                );
                // bottom right curve
                ctx.bezierCurveTo(
                    this.x, this.y + (this.size + topCurveHeight) / 2, 
                    this.x + this.size / 2, this.y + (this.size + topCurveHeight) / 2, 
                    this.x + this.size / 2, this.y + topCurveHeight
                );
                // top right curve
                ctx.bezierCurveTo(
                    this.x + this.size / 2, this.y, 
                    this.x, this.y, 
                    this.x, this.y + topCurveHeight
                );
                ctx.fill();
            }

            update() {
                this.y += this.speed;
            }
        }

        // Particle Effect
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.speedX = (Math.random() - 0.5) * 4;
                this.speedY = (Math.random() - 0.5) * 4;
                this.life = 100;
                this.color = `rgba(255, 255, 255, 0.8)`;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= 2;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = Math.max(0, this.life / 100);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Input Handling
        function handleInput(e) {
            if (!player || gameState !== 'PLAYING') return;
            
            // Mouse / Touch
            let clientX;
            if (e.type === 'mousemove') {
                clientX = e.clientX;
            } else if (e.type === 'touchmove') {
                e.preventDefault(); // Stop scrolling on mobile
                clientX = e.touches[0].clientX;
            }
            
            if (clientX) {
                player.x = clientX - player.w / 2;
            }
        }

        window.addEventListener('mousemove', handleInput);
        window.addEventListener('touchmove', handleInput, { passive: false });

        // Game Functions
        function spawnHeart() {
            if (Math.random() < 0.03) { // Slight increase in spawn rate
                hearts.push(new Heart());
            }
        }

        function updateGame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            if (gameState === 'PLAYING') {
                player.update();
                player.draw();

                spawnHeart();

                for (let index = hearts.length - 1; index >= 0; index--) {
                    let heart = hearts[index];
                    heart.update();
                    heart.draw();

                    // Collision Detection
                    if (
                        heart.y + heart.size > player.y &&
                        heart.x > player.x &&
                        heart.x < player.x + player.w
                    ) {
                        // Catch!
                        hearts.splice(index, 1);
                        score++;
                        createParticles(heart.x, heart.y);
                        updateScore();
                        
                        if (score >= WIN_SCORE) {
                            triggerProposal();
                        }
                    } else if (heart.y > canvas.height) {
                        hearts.splice(index, 1); // Missed
                    }
                }

                for (let idx = particles.length - 1; idx >= 0; idx--) {
                    let p = particles[idx];
                    p.update();
                    p.draw();
                    if (p.life <= 0) particles.splice(idx, 1);
                }
            }

            animationId = requestAnimationFrame(updateGame);
        }

        function createParticles(x, y) {
            for(let i=0; i<8; i++) {
                particles.push(new Particle(x, y));
            }
        }

        function updateScore() {
            const percentage = Math.min((score / WIN_SCORE) * 100, 100);
            loveMeter.style.width = `${percentage}%`;
        }

        function triggerProposal() {
            gameState = 'PROPOSAL';
            setTimeout(() => {
                proposalScreen.classList.remove('hidden');
                proposalScreen.classList.add('active');
            }, 500);
        }

        function startGame() {
            resize();
            player = new Player();
            hearts = [];
            particles = [];
            score = 0;
            updateScore();
            gameState = 'PLAYING';
            
            startScreen.classList.remove('active');
            startScreen.classList.add('hidden');
            
            // Ensure loop isn't running twice
            if(animationId) cancelAnimationFrame(animationId);
            updateGame();
        }

        // Event Listeners
        startBtn.addEventListener('click', startGame);

        yesBtn.addEventListener('click', () => {
            proposalScreen.classList.remove('active');
            proposalScreen.classList.add('hidden');
            celebrationScreen.classList.remove('hidden');
            celebrationScreen.classList.add('active');
        });

        // "No" button runs away
        // Use standard function instead of arrow to allow proper removal if needed, though not strictly necessary here.
        function moveNoButton() {
            // Get viewport dimensions
            const maxX = window.innerWidth - noBtn.offsetWidth - 20;
            const maxY = window.innerHeight - noBtn.offsetHeight - 20;
            
            const x = Math.random() * maxX;
            const y = Math.random() * maxY;
            
            noBtn.style.position = 'fixed'; // Switch to fixed to break out of layout
            noBtn.style.left = `${Math.max(20, x)}px`;
            noBtn.style.top = `${Math.max(20, y)}px`;
        }

        noBtn.addEventListener('mouseover', moveNoButton);
        noBtn.addEventListener('touchstart', moveNoButton); // Mobile support

        // Initialize
        resize();
    </script>
</body>
</html>